! This file is not part of GS2, but exists to document those variables which are also input parameters. It is generated automatically by CodeRunner from its input parameter database. To update this database, DO NOT edit this file,  your changes will be lost: go to the wiki page for the input parameters (http://sourceforge.net/apps/mediawiki/gyrokinetics/index.php?title=Gs2_Input_Parameters) and follow the instructions there. 

module theta_grid_eik


   !>In general, \f$\beta\f$ is the ratio of kinetic to magnetic energy.  In GS2, the parameter \f$\beta\f$ affects only the dynamics, not the equilibrium.  
  !!  - For electromagnetic runs, the contribution of each species to the total parallel current is weighted by a factor of \f$w_s = 2 \beta Z_s n_s \sqrt{T_s/m_s}\f$.
  !!  - For electromagnetic runs that include \f$\delta B_\parallel\f$, this field is proportional to \f$\beta\f$.
  !!  - The contribution of \f$(\delta B)^2\f$ to the total gyrokinetic energy is inversely proportional to this input parameter.
  !!  - If an antenna is set up to drive Alfven waves, then \f$\beta\f$ is used to calculate the Alfven frequency.  
  !!  - For some collision operator models, \f$\beta\f$ is used to calculate the resistivity.  
  !!  - For some rarely-used initial conditions, \f$\beta\f$ appears explicitly. 
  !!  - Important:  \f$\beta\f$ is <b>not</b> automatically set to be consistent with the value of \f$\beta\f$ used to calculate properties of a given magnetic equilibrium.  The user is responsible for choosing the gradients, densities, and temperatures of all species to be consistent with the values of \f$\beta\f$ and \f$\beta'\f$ which appear here and elsewhere.
 real :: beta
end module theta_grid_eik
module run_parameters


   !>Effective ionic charge.  The parameter \f$Z_{\rm eff}\f$ appears only in the electron collision frequency, and is not automatically set to be consistent with the mix of species specified in the species namelists.
 real :: zeff
end module run_parameters
module run_parameters


   !>Ratio of electron to ion temperatures.  Deprecated.  Do not use unless you know what you are doing.
 real :: teti
end module run_parameters
module run_parameters


   !>Ratio of ion to electron temperatures.  This parameter is used only when there is no species called "electron" included.
 real :: tite
end module run_parameters
module kt_grids


   !>The general layout of the perpendicular grid.
  !!  -  'single' Evolve a single Fourier mode.  Set up kt_grids_single_parameters.
  !!  -  'default' Same as 'single'
  !!  -  'range' Evolve a range of equally spaced Fourier modes. Set up kt_grids_range_parameters.
  !!  -  'specified' Evolve an arbitrary set of Fourier modes.  Set up kt_grids_specified_parameters.
  !!  -  'box' Simulation domain is logically rectangular.  Set up kt_grids_box_parameters.
  !!  -  'nonlinear' Same as 'box.'
  !!  -  'xbox' Experimental.
 character :: grid_option
end module kt_grids
module kt_grids_specified


   !>The number of kx modes: the number of kx modes actually simulated (ntheta0) is equal to 2*(nx - 1)/3 + 1, due to the need to prevent aliasing.
 integer :: nx
end module kt_grids_specified
module kt_grids_specified


   !>The number of ky modes: the number of ky modes actually simulated (naky) is equal to (ny - 1)/3 + 1, due to the need to prevent aliasing.
 integer :: ny
end module kt_grids_specified
module kt_grids_box


   !>For finite magnetic shear, determines box size in x direction according to 
  !!  -  \f$L_x = L_y  jtwist / (2 \pi \hat{s}) \f$
  !!  -  Also affects the number of "connections" at each ky when linked boundary conditions are selected in the dist_fn_knobs namelist.
 integer :: jtwist
end module kt_grids_box
module kt_grids_box


   !>The length of the box in the y direction (measured in the Larmour radius of species 1).  Box size in y direction is 2*pi*y0.
 real :: y0
end module kt_grids_box
module kt_grids_box


   !>The length of the box in the x direction (measured in the Larmour radius of species 1) if shat is 0 (ie 1e-6)
 real :: x0
end module kt_grids_box
module kt_grids_specified


   !>Number of ky values evolved. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: naky
end module kt_grids_specified
module kt_grids_specified


   !>Number of theta0 values. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: ntheta0
end module kt_grids_specified
module hyper


   !> Box size in y direction.
  !!  -  If ly=0, it is set to be 2*pi*y0 (below).
 real :: ly
end module hyper
module kt_grids_box


   !> Experts only.
 real :: rtwist
end module kt_grids_box
module kt_grids_single


   !> ky rho
 real :: aky
end module kt_grids_single
module kt_grids_single


   !>  theta_0
 real :: theta0
end module kt_grids_single
module kt_grids_single


   !> kx rho (but set theta_0 instead.)
 real :: akx
end module kt_grids_single
module kt_grids_specified


   !>Number of grid points along equilibrium magnetic field between \f$\theta=(-\pi,\pi)\f$ (in addition to a grid point at \f$\theta=0\f$).
  !!  -  Ignored in some cases
 integer :: ntheta
end module kt_grids_specified
module theta_grid_params


   !>Sets the number of \f$2\pi\f$ segments along equilibrium magnetic field to include in simulation domain.  \f$N_{\rm segments} = (2n_{\rm period} - 1)\f$.
  !!  -  Ignored in some cases
 integer :: nperiod
end module theta_grid_params
module theta_grid_gridgen


   !>Controls particle trapping (among other things) in simple geometric models.  \f$\epsilon = r/R\f$
 real :: eps
end module theta_grid_gridgen
module theta_grid_params


   !>Sets curvature drift in simple geometric models.  \f$\epsilon_\ell = 2 a / R \f$, where a is the GS2 normalisation length and R is the major radius at the centre of the flux surface.
 real :: epsl
end module theta_grid_params
module theta_grid_params


   !>Sets value of magnetic shear in simple geometric models.
  !!  -  over-ridden by s_hat_input in theta_grid_eik_knobs for most values of bishop.
 real :: shat
end module theta_grid_params
module theta_grid_gridgen


   !>\f$p_k = 2 a / q R\f$ - when using high aspect ratio, \f$s-\alpha\f$ model for geometry it sets q, the magnetic safety factor, since the ratio 2a/R is set by epsl. It therefore also sets the connection length, i.e. the length of the box in the parallel direction, in terms of a, the GS2 normalization quantity.
 real :: pk
end module theta_grid_gridgen
module hyper


   !>If kp > 0 then pk = 2*kp. Set kp rather than pk in the slab. Since in the slab limit, shat =  2a/ (L_S pk), this means that if kp = 1, shat = a/ L_S, where L_S is the magnetic shear scale length.
  !!
  !!Sets parallel box length when geometry is unsheared slab.  \f$k_p = 2 \pi /L_z\f$.
 real :: kp
end module hyper
module theta_grid_params


   !>rhoc is flux surface label (0< rhoc< 1). Its exact meaning depends on irho. Usually rho = diameter/diameter of LCFS
  !!  -  When irho = 1, rhoc = sqrt(toroidal flux)/sqrt(toroidal flux of LCFS)
  !!  -  When irho = 2, rhoc =  diameter/(diameter of LCFS).  recommended
  !!  -  When irho = 3, rhoc =  poloidal flux/(poloidal flux of LCFS)
 real :: rhoc
end module theta_grid_params
module theta_grid_params


   !>Sets value of the safety factor when using local toroidal equilibrium model.
 real :: qinp
end module theta_grid_params
module theta_grid_params


   !>Sets local elongation when local toroidal equilibrium is specified.
 real :: akappa
end module theta_grid_params
module theta_grid_params


   !>Sets local gradient of elongation when local toroidal equilibrium is specified.
  !!  -  akappri = \f$ d\kappa/d\rho \f$
 real :: akappri
end module theta_grid_params
module theta_grid_params


   !>Sets local triangularity when local toroidal equilibrium is specified.
  !!  -  triangularity is tri = arcsin[(R(max(Z))-R_major)/r_mid]
 real :: tri
end module theta_grid_params
module theta_grid_params


   !>Sets local gradient of triangularity when local toroidal equilibrium is specified.
  !!  -  tripri =  \f$dtri/d\rho\f$
 real :: tripri
end module theta_grid_params
module theta_grid_params


   !>Related to Shafranov shift.  Sign depends on geometric model. ?? Exact definition uncertain... please edit if you know! ?? Could be
  !!  -  \f$shift = -R q**2 d\beta/d\rho (>0) \f$ ??
  !!  -  dR/drho (R normalized to a) (< 0) ??
 real :: shift
end module theta_grid_params
module theta_grid_salpha


   !>Default = 0.  Do not use unless you know what you are doing.
 real :: alpmhd
end module theta_grid_salpha
module theta_grid_params


   !>- asympri:
 real :: asym
end module theta_grid_params
module theta_grid_params


   !>Major radius/a (Position of magnetic axis)
 real :: rmaj
end module theta_grid_params
module theta_grid_params


   !>Major radius/a (centerpoint of LCFS)
 real :: r_geo
end module theta_grid_params
module dist_fn


   !>In the slab limit, determines the angle between the field and the background flow (which flows in an imaginary toroidal direction). It is effectively equal to \f$\frac{B_t}{B}=\frac{u_{\parallel}}{u}\f$.
 real :: btor_slab
end module dist_fn
module theta_grid


   !>The equilibrium_option variable controls which geometric assumptions are used in the run.  Additional namelists determine the geometric parameters according to the choice made here. Allowed values are:
  !!  -  'eik' Use routines from the geometry module, controlled mainly by the subsidiary namelists theta_grid_parameters and theta_grid_eik_knob.
  !!  -  'default' Same as 'eik'                                                                                                                          
  !!  -  's-alpha' Use high aspect-ratio toroidal equilbrium (which can be simplified to slab or cylinder), controlled by the subsidiary namelist theta_grid_parameters and  theta_grid_salpha_knob
  !!  -  'file'  Use output from rungridgen code directly.  Controlled by theta_grid_file_knobs. Note: in this case, the variables nperiod and ntheta (from the theta_grid_parameters namelist) are ignored.
  !!  -  'grid.out'  Same as 'file'
 character :: equilibrium_option
end module theta_grid
module theta_grid_salpha


   !>  -  's-alpha' High aspect ratio toroidal equilibrium.  (Note that the curvature and grad-B drifts are equal.)
  !!  -  'default' Same as 's-alpha'
  !!  - 
  !!'alpha1','rogers','b2','normal_only',const-curv',no-curvature': See output of ingen until this page is improved.
 character :: model_option
end module theta_grid_salpha
module theta_grid_salpha


   !> 
 real :: alpmhdfac
end module theta_grid_salpha
module theta_grid_salpha


   !> 
 real :: alpha1
end module theta_grid_salpha
module theta_grid_file


   !> Name of file with output from rungridgen.
 character :: gridout_file
end module theta_grid_file
module theta_grid_gridgen


   !> 
 integer :: npadd
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: alknob
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: epsknob
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: bpknob
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: extrknob
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: tension
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: thetamax
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: deltaw
end module theta_grid_gridgen
module theta_grid_gridgen


   !> 
 real :: widthw
end module theta_grid_gridgen
module theta_grid_eik


   !> Do not change.
 integer :: itor
end module theta_grid_eik
module theta_grid_eik


   !> Choose mode of operation: 
  !!  -  0: Use Miller parameterization of local toroidal MHD equilibrium.
  !!  -  1: Read equilibrium data from output of MHD code
  !!  -  2: Running inside a transport code without numerical equilibrium
 integer :: iflux
end module theta_grid_eik
module theta_grid_eik


   !> Choose definition of flux surface coordinate
  !!  -  1: rho == sqrt(toroidal flux)/sqrt(toroidal flux of LCFS)
  !!  -  2: rho == midplane diameter/LCFS diameter   &nbsp; Recommended
  !!  -  3: rho == poloidal flux/poloidal flux of LCFS
  !!  -  
 integer :: irho
end module theta_grid_eik
module theta_grid_eik


   !> Use Miller-style local equilibrium
 character :: local_eq
end module theta_grid_eik
module theta_grid_eik


   !> Name of file with numerical equilibrium data (if required)
 character :: eqfile
end module theta_grid_eik
module theta_grid_eik


   !> Use Bishop relations to generate metric coefficients.
  !!  -  0: Use high-aspect ratio coefficients (only for debugging)
  !!  -  1: Use actual equilibrium values of shat, p'  Recommended 
  !!  -  2: Use numerical equilibrium + s_hat_input and p_prime_input
  !!  -  3: Use numerical equilibrium + s_hat_input and inv_Lp_input
  !!  -  4: Use numerical equilibrium + s_hat_input and beta_prime_input 
  !!  -  5: Use numerical equilibrium + s_hat_input and alpha_input
  !!  -  6: Use numerical equilibrium + beta_prime_input
  !!  -  7: Use numerical equilibrium and multiply pressure gradient by dp_mult
  !!  -  8: Use numerical equilibrium + s_hat_input and multiply pressure gradient by dp_mult
  !!  -  9: Use numerical equilibrium + s_hat_input and beta_prime_input
  !!  -  Otherwise: Use magnetic shear and pressure gradient as set elsewhere.
  !!  -  
 integer :: bishop
end module theta_grid_eik
module theta_grid_eik


   !> Overrides shat.
 real :: s_hat_input
end module theta_grid_eik
module theta_grid_eik


   !>The gradient of the pressure. Strictly speaking this parameter is not \f$\frac{\partial \beta}{\partial \rho} \f$ but \f$\beta \frac{1}{p}\frac{\partial p}{\partial \rho}\f$: in other words, the gradient of the magnetic field is ignored. Used only if bishop = 4 or 9.
 real :: beta_prime_input
end module theta_grid_eik
module theta_grid_eik


   !> Default usually okay
 real :: delrho
end module theta_grid_eik
module theta_grid_eik


   !>  -  0:  Recommended 
  !!  -  1: Force up-down symmetry.
 integer :: isym
end module theta_grid_eik
module theta_grid_eik


   !> Use Menard-style NetCDF equilibrium (JSOLVER)
 logical :: ppl_eq
end module theta_grid_eik
module theta_grid_eik


   !> Use Toq-style NetCDF equilibrium (TOQ)
 logical :: gen_eq
end module theta_grid_eik
module theta_grid_eik


   !> Use EFIT equilibrium (EFIT, codes with eqdsk format)
 logical :: efit_eq
end module theta_grid_eik
module theta_grid_eik


   !> Change field-line coordinate.  Recommended value: F
 logical :: equal_arc
end module theta_grid_eik
module theta_grid_eik


   !> Write a little extra about geometry to the screen.
 logical :: writelots
end module theta_grid_eik
module theta_grid_eik


   !> Vacuum magnetic dipole geometry
 logical :: dfit_eq
end module theta_grid_eik
module theta_grid_eik


   !> Read Colin Roach's GS2D equilibrium file
 logical :: gs2d_eq
end module theta_grid_eik
module theta_grid_eik


   !> Use new PPL NetCDF equilibrium (TRANSP)
 logical :: transp_eq
end module theta_grid_eik
module theta_grid_eik


   !> Used only if bishop = 5.  Needs to be checked.
 real :: alpha_input
end module theta_grid_eik
module theta_grid_eik


   !> Used only if bishop = 7 or 8.  
 real :: dp_mult
end module theta_grid_eik
module theta_grid_eik


   !> Never used
 real :: rmin
end module theta_grid_eik
module theta_grid_eik


   !>  Never used
 real :: rmax
end module theta_grid_eik
module le_grids


   !>No. of standard deviations from the standard Maxwellian beyond which the distribution function will be set to 0
 real :: vcut
end module le_grids
module le_grids


   !>Number of untrapped pitch-angles moving in one direction along field line.
 integer :: ngauss
end module le_grids
module le_grids


   !>Total number of energy grid points
 integer :: negrid
end module le_grids
module le_grids


   !> Should not have to change this
 real :: bouncefuzz
end module le_grids
module le_grids


   !> Only used if advanced_egrid = F; sets number of energy grid points above ecut
 integer :: nesuper
end module le_grids
module le_grids


   !> Only used if advanced_egrid = F; sets number of energy grid points below ecut
 integer :: nesub
end module le_grids
module le_grids


   !> 
 logical :: trapped_particles
end module le_grids
module dist_fn


   !>Affects boundary condition at end of theta grid.   Recommended value: 1.
 real :: gridfac
end module dist_fn
module dist_fn


   !>Sets the boundary condition along the field line (i.e. the boundary conditions at theta = +- pi). Possible values are: 
  !!'zero', 'default', 'unconnected' - Use Kotschenreuther boundary condition at endpoints of theta grid
  !!'self-periodic', 'periodic', 'kperiod=1' - Each mode is periodic in theta with itself
  !!'linked' - Twist and shift boundary conditions
  !!'alternate-zero' - Ignored
 character :: boundary_option
end module dist_fn
module dist_fn


   !>The form of the adiabatic response (if a species is being modeled as adiabatic). Ignored if there are electrons in the species list.
  !!  -   'no-field-line-average-term'  Adiabatic species has n = Phi.  Appropriate for single-species ETG simulations. 
  !!  -   'default'  Same as 'no-field-line-average-term'
  !!  -   'iphi00=0' Same as 'no-field-line-average-term'
  !!  -   'iphi00=1' Same as 'no-field-line-average-term'
  !!  -   'field-line-average-term'  Adiabatic species has n=Phi-< Phi >.  Appropriate for single-species ITG simulations.
  !!  -   'iphi00=2' Same as field-line-average-term'
  !!  -   'iphi00=3' Adiabatic species has n=Phi-< Phi >_y.  Incorrect implementation of field-line-average-term.
 character :: adiabatic_option
end module dist_fn
module dist_fn


   !>For debugging only.
 character :: test
end module dist_fn
module dist_fn


   !> Leave as unity.  For debugging.
 real :: apfac
end module dist_fn
module dist_fn


   !> Leave as unity.  For debugging/
 real :: driftknob
end module dist_fn
module dist_fn


   !> If non-zero, quasineutrality is not enforced; poisfac=  (lambda_Debye/rho)**2 
 real :: poisfac
end module dist_fn
module dist_fn


   !> For debugging only.
 real :: kfilter
end module dist_fn
module dist_fn


   !> For debugging only.
 real :: afilter
end module dist_fn
module dist_fn


   !> Allow different species to have different values of bakdif and fexpr.   Not allowed for nonlinear runs. 
 logical :: mult_imp
end module dist_fn
module dist_fn


   !> True only allows solutions of single parity.
 logical :: def_parity
end module dist_fn
module dist_fn


   !>Include calculation of terms present in the low flow limit of gyrokinetics. Many new terms... will slow calculation... don't set true unless you know what you are doing.
 logical :: include_lowflow
end module dist_fn
module dist_fn


   !>Multiplies g_exb in the perpendicular shearing term ''but not'' in the parallel drive term. Use for simulations with purely parallel flow.
 real :: g_exbfac
end module dist_fn
module dist_fn


   !>Normalised gyro-radius, \f$\frac{\rho}{a}\f$, needed for calculating the momentum flux in the low flow limit.
 real :: rhostar
end module dist_fn
module fields


   !>The field_option variable controls which time-advance algorithm is used for the linear terms. Allowed values are:                                          
  !!  -  'implicit' Advance linear terms with Kotschenreuther's implicit algorithm.                                                                   
  !!  -  'default'  Same as 'implicit'                                                                                                                     
  !!  -  'explicit' Use second-order Runge-Kutta.  Experimental.                                                                                          
  !!  -  'test' Use for debugging.
 character :: field_option
end module fields
module fields


   !>Delete zonal flows at every timestep.
 logical :: remove_zonal_flows_switch
end module fields
module run_parameters


   !>Default = .false.  Make the timestep proportional to \f$k_y \rho\f$.  This can be useful for linear stability calculations that have a wide range of \f$k_y\f$ values.  Do not set to true for nonlinear runs.  Be aware that the units of some output quantities can change when wstar_units = .true.
 character :: wstar_units
end module run_parameters
module run_parameters


   !>Multiplies \f$\Phi\f$ (electrostatic potential) throughout.  Useful for debugging. Non-experts use 1.0
 real :: fphi
end module run_parameters
module run_parameters


   !>Multiplies \f$A_\parallel\f$ throughout.  Set to zero for electrostatic calculations, or unity for electromagnetic.  Set to zero if \f$\beta = 0\f$.
 real :: fapar
end module run_parameters
module run_parameters


   !>Multiplies A_perp. Use 1 for high beta, 0 otherwise. Deprecated: use fbpar instead. Defaults to zero.  Do not change this value unless you know what you are doing.
 real :: faperp
end module run_parameters
module run_parameters


   !>Multiplies \f$B_\parallel\f$ throughout.  Set to zero or unity, depending on whether you want to include physics related to \f$\delta B_\parallel\f$. Set to zero if \f$\beta = 0\f$.
 real :: fbpar
end module run_parameters
module run_parameters


   !>Deprecated.  Do not use.  (Use 'check_restart' to get initial timestep from restart file, 'default' otherwise.)
 character :: delt_option
end module run_parameters
module theta_grid_gridgen


   !>Timestep, in units of \f$a/v_{t0}\f$.  For linear runs, this value does not change.  For nonlinear runs, the timestep used by the code will not be allowed to exceed this value.
 real :: delt
end module theta_grid_gridgen
module run_parameters


   !>Default = .false.   Do not evolve certain \f$k\f$ modes in time.  Set this to true only if you know what you are doing. True only for secondary/tertiary instability calculations.
 logical :: eqzip
end module run_parameters
module run_parameters


   !> Obsolete.  Fraction of T3E batch job used for finishing up.
 real :: margin
end module run_parameters
module run_parameters


   !>Default = .false.  Do not set to true unless you know what you are doing.
 logical :: secondary
end module run_parameters
module run_parameters


   !>Default = .false.  Do not set to true unless you know what you are doing.
 logical :: tertiary
end module run_parameters
module run_parameters


   !>Default = .false.  Do not set to true unless you know what you are doing.
 logical :: harris
end module run_parameters
module run_parameters


   !>Specify the available wall clock time in seconds. GS2 will exit before this time. This ensures that all the output files are written correctly.  CodeRunner automatically sets this quantity unless it is given the value false.
 real :: avail_cpu_time
end module run_parameters
module gs2_reinit


   !>When the time step needs to be changed, it is adjusted 
 real :: delt_adj
end module gs2_reinit
module gs2_reinit


   !>The minimum time step is delt_minimum.
 real :: delt_minimum
end module gs2_reinit
module gs2_layouts


   !>Determines the way the grids are laid out in memory. Rightmost is parallelised first. 
  !!  -  Can be 'yxles', 'lxyes', 'lyxes', 'lexys' 
  !!  -  Strongly affects performance on parallel computers
  !!  -  In general avoid parallelizing over x. For this reason 'lxyes' is often a good choice.
 character :: layout
end module gs2_layouts
module gs2_layouts


   !>Strongly affects initialization time on some parallel computers. 
  !!  -   Recommendation:  Use T on computers with slow communication networks.
 character :: local_field_solve
end module gs2_layouts
module collisions


   !>Collision model used in the simulation. 
  !!  -  ''default'' = pitch angle scattering and energy diffusion
  !!  -  ''collisionless'',''none'' = collisionless
  !!  -  ''lorentz'' =  pitch angle scattering only
  !!  -  ''ediffuse'' = energy diffusion only
  !!  -  ''krook'' = use home made krook operator (no reason to use this!)
 character :: collision_model
end module collisions
module hyper


   !>'default' is 'none'
 character :: hyper_option
end module hyper
module nonlinear_terms


   !>Should the nonlinear terms be calculated?
  !!  -  'none', 'default', 'off':  Do not include nonlinear terms, i.e. run a linear calculation.
  !!  -  'on' Include nonlinear terms.
 character :: nonlinear_mode
end module nonlinear_terms
module nonlinear_terms


   !> Experimental
 character :: flow_mode
end module nonlinear_terms
module nonlinear_terms


   !>The maximum delt < cfl * min(Delta_perp/v_perp)
 real :: cfl
end module nonlinear_terms
module run_parameters


   !> Experts only (for secondary/tertiary calculations). 
 logical :: zip
end module run_parameters
module species


   !>Number of kinetic species evolved.
 integer :: nspec
end module species
module fields


   !>Charge
 real :: z
end module fields
module file_utils


   !>Temperature
 real :: temp
end module file_utils
module dist_fn


   !>Temporal implicitness parameter. Any value other than 0.5 adds numerical dissipation.
  !!  -  Recommended value: 0.48
 real :: fexpr
end module dist_fn
module dist_fn


   !>Spatial implicitness parameter. Any value greater than 0 adds numerical dissipation (usually necessary).
  !!  -  Recommended value: 0.05
 real :: bakdif
end module dist_fn
module dist_fn


   !>Used in rare cases.
 real :: imfac
end module dist_fn
module init_g


   !>Initial perturbation has Gaussian envelope in theta, with width width0
 real :: width0
end module init_g
module init_g


   !>Base of filenames with restart data.
 character :: restart_file
end module init_g
module init_g


   !> Force t=tstart at beginning of run.
 real :: tstart
end module init_g
module dist_fn


   !> Sometimes initial conditions have definite parity; this picks the parity in those cases.
 logical :: even
end module dist_fn
module gs2_diagnostics


   !>Instantaneous fluxes output to screen every nwrite timesteps
 logical :: print_flux_line
end module gs2_diagnostics
module gs2_diagnostics


   !>Phi**2(kx,ky) written to runname.out
 logical :: write_nl_flux
end module gs2_diagnostics
module gs2_diagnostics


   !>Estimated frequencies and output to the screen/stdout every nwrite timesteps
 logical :: print_line
end module gs2_diagnostics
module gs2_diagnostics


   !>Write velocity space diagnostics to '.lpc' and '.verr' files
 logical :: write_verr
end module gs2_diagnostics
module gs2_diagnostics


   !>Write the distribution function to the '.dist' (NetCDF?)
 logical :: write_g
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) write estimated frequencies and growth rates to the output file (usually runname.out) every nwrite steps.
 logical :: write_line
end module gs2_diagnostics
module gs2_diagnostics


   !>Write dist fn at a given physical spacial point to a file
 logical :: write_gyx
end module gs2_diagnostics
module gs2_diagnostics


   !>Write heating rate, collisonal entropy generation etc to '.heat'
 logical :: write_hrate
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) E_parallel(theta) written to runname.eigenfunc
  !!  -  Write to runname.out.nc even if (write_ascii = F)
 logical :: write_final_epar
end module gs2_diagnostics
module gs2_diagnostics


   !>Ignored unless grid_option='box'
  !!  -  Flux surface averaged low-order moments of g written to runname.out.nc
  !!  -  If (write_ascii = T) flux surface averaged low-order moments of g written to runname.moments
 logical :: write_avg_moments
end module gs2_diagnostics
module gs2_diagnostics


   !>Frequency Sweep Data
 logical :: write_lorentzian
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) instantaneous omega to output file every nwrite timesteps. Very heavy output.
 logical :: write_omega
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) time-averaged frequencies written to runname.out every nwrite timesteps.
  !!  -  Average is over navg steps.
 logical :: write_omavg
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) Normalized Phi(theta) written to runname.eigenfunc
  !!  -  Write to runname.out.nc even if (write_ascii = F)
 logical :: write_eigenfunc
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) Phi(theta) written to runname.fields
  !!  -  Write to runname.out.nc even if (write_ascii = F)
 logical :: write_final_fields
end module gs2_diagnostics
module gs2_diagnostics


   !>If (write_ascii = T) low-order moments of g written to runname.moments and int dl/B averages of low-order moments of g written to  runname.amoments
  !!  -  Write to runname.out.nc even if (write_ascii = F)
 logical :: write_final_moments
end module gs2_diagnostics
module gs2_diagnostics


   !>Writes parities in dist fn and particle fluxes
 logical :: write_parity
end module gs2_diagnostics
module gs2_diagnostics


   !>Write restart files every nsave timesteps
 integer :: nsave
end module gs2_diagnostics
module gs2_diagnostics


   !>Output diagnostic data every nwrite timesteps.
 integer :: nwrite
end module gs2_diagnostics
module gs2_diagnostics


   !>Any time averages performed over navg timesteps.
 integer :: navg
end module gs2_diagnostics
module gs2_diagnostics


   !>In linear runs GS2 will exit if the growth rate has converged to an accuracy of one part in 1/omegatol. Set negative to switch off this feature.
 real :: omegatol
end module gs2_diagnostics
module gs2_diagnostics


   !>Recommended value: 500.
 real :: omegatinst
end module gs2_diagnostics
module gs2_diagnostics


   !>If true then restart files written to the local folder and the simulation can be restarted from the point it ended.
  !!  -  Restart files written to restart_file.PE#.  
  !!  -  Recommended for nonlinear runs.
 logical :: save_for_restart
end module gs2_diagnostics
module gs2_diagnostics


   !> If (write_ascii = T) instantaneous fluxes output to runname.out every nwrite timesteps
 logical :: write_flux_line
end module gs2_diagnostics
module gs2_diagnostics


   !> If true, some data is written to runname.out
 logical :: write_ascii
end module gs2_diagnostics
module gs2_diagnostics


   !> Spectrum in k_parallel calculated and written.
 logical :: write_kpar
end module gs2_diagnostics
module gs2_diagnostics


   !> If (write_ascii = T) Sources for Maxwell eqns. written to runname.antot
  !!  -  Write to runname.out.nc even if (write_ascii = F)
 logical :: write_final_antot
end module gs2_diagnostics
module gs2_diagnostics


   !> Theta index at which frequencies are calculated.
 integer :: igomega
end module gs2_diagnostics
module gs2_diagnostics


   !> When the frequencies for each k have converged, the run will stop.
 logical :: exit_when_converged
end module gs2_diagnostics
module gs2_diagnostics


   !> Field-line avg of Phi written to dump.check1
 logical :: dump_check1
end module gs2_diagnostics
module gs2_diagnostics


   !> Apar(kx, ky, igomega) written to dump.check2
 logical :: dump_check2
end module gs2_diagnostics
module gs2_diagnostics


   !> Phi, Apar, Bpar written to dump.fields.t=(time).  This is expensive!
 logical :: dump_fields_periodically
end module gs2_diagnostics
module gs2_diagnostics


   !>If this variable is set to true then the entire field Phi will be written to the NetCDF file every nwrite. Useful for making films. This can cause the NetCDF file to be huge, if resolution is large or nwrite is small.
 logical :: write_phi_over_time
end module gs2_diagnostics
module gs2_diagnostics


   !>If this variable is set to true then the entire field A_parallel will be written to the NetCDF file every nwrite. This can cause the NetCDF file to be huge, if resolution is large or nwrite is small.
 logical :: write_apar_over_time
end module gs2_diagnostics
module gs2_diagnostics


   !>If this variable is set to true then the entire field B_parallel will be written to the NetCDF file every nwrite. Useful for making films. This can cause the NetCDF file to be huge, if resolution is large or nwrite is small.
 logical :: write_bpar_over_time
end module gs2_diagnostics
module gs2_diagnostics


   !>Switch on a diagnostic to test the symmetry properties of the GK eqn.  It calculates the momentum flux as a function of vpar, theta, and time.
 logical :: write_symmetry
end module gs2_diagnostics
module gs2_diagnostics


   !>If true, saves the restart files with name 'rootname.nc.dfn.<proc>' with lots of extra detail about the dist function --- velocity space grids and so on, when GS2 exits.
 logical :: save_distfn
end module gs2_diagnostics
module gs2_diagnostics


   !>If used in conjunction with write_correlation, extends the length of \f$\Delta \theta\f$ for which the correlation function is calculated.
 logical :: write_correlation_extend
end module gs2_diagnostics
module gs2_diagnostics


   !>Multiplies nwrite to determine when large/expensive to calculate datasets such as the parallel correlation function are written to file.
 integer :: nwrite_mult
end module gs2_diagnostics
module gs2_diagnostics


   !>Write correlation function diagnostic... shows parallel correlation as a function of ky. See arXiv 1104.4514.
 logical :: write_correlation
end module gs2_diagnostics
module antenna


   !> Amplitude of Langevin antenna.
 real :: amplitude
end module antenna
module dist_fn


   !> Turn on any artificial sources after time t0.
 real :: t0
end module dist_fn
module dist_fn


   !> Frequency of non-standard source (if selected above). 
 real :: omega0
end module dist_fn
module dist_fn


   !> Growth rate of non-standard source (if selected above). 
 real :: gamma0
end module dist_fn
module dist_fn


   !> Amplitude of non-standard source (if selected above). 
 real :: source0
end module dist_fn
module dist_fn


   !> Amplitude of external Phi added as source term.
 real :: phi_ext
end module dist_fn
module dist_fn


   !>  -  'source_option_full' Solve GK equation in standard form (with no artificial sources)
  !!  -  'default' Same as 'source_option_full' 
  !!  -  'zero' The GK distribution function will be advanced non-self-consistently.
  !!  -  'sine' The GK distribution function will be advanced non-self-consistently.
  !!  -  'cosine'The GK distribution function will be advanced non-self-consistently.
  !!  -  'test1' The GK distribution function will be advanced non-self-consistently.
  !!  -  'phiext_full' Solve GK equation with additional source proportional to phi_ext*F_0.  
  !!  -  'test2_full' Solve GK equation with additional developmental sources included.  Experts only.
  !!  -  'convect_full' Solve GK equation with additional developmental sources included.  Experts only.
  !!  -  'test1' The GK distribution function will be advanced non-self-consistently.
 character :: source_option
end module dist_fn
module kt_grids_specified


   !>Number of ky values evolved. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: naky
end module kt_grids_specified
module kt_grids_specified


   !>Number of theta0 values. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: ntheta0
end module kt_grids_specified
module kt_grids_range


   !> Lower limit of (ky rho) range.  Should set to something other than zero.
 real :: aky_min
end module kt_grids_range
module kt_grids_range


   !> Upper limit of (ky rho) range.  Should set to something other than zero.
 real :: aky_max
end module kt_grids_range
module kt_grids_range


   !> Lower limit of theta_0 range
 real :: theta0_min
end module kt_grids_range
module kt_grids_range


   !> Upper limit of theta_0 range
 real :: theta0_max
end module kt_grids_range
module kt_grids_range


   !>Min kx for periodic finite kx ballooning space runs with \f$\hat{s}=0\f$.
 real :: akx_min
end module kt_grids_range
module kt_grids_range


   !>Max kx for periodic finite kx ballooning space runs with shat=0.
 real :: akx_max
end module kt_grids_range
module kt_grids_specified


   !>Number of ky values evolved. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: naky
end module kt_grids_specified
module kt_grids_specified


   !>Number of theta0 values. Total number of modes evolved = max(naky, ntheta0). Also set up the appropriate number of kt_grids_specified_element_i namelists.
 integer :: ntheta0
end module kt_grids_specified
module kt_grids_single


   !> ky rho
 real :: aky
end module kt_grids_single
module kt_grids_single


   !>  theta_0
 real :: theta0
end module kt_grids_single
module parameter_scan


   !>Specifies the way that the parameter scan is conducted. Possible values are:
  !!  -  'none' -- do not conduct a parameter scan (default)
  !!  -  'range' --  vary parameter in constant increments between 2 values: par_start and par_end. The step size is given by par_inc.
  !!  -  'target' --  start with the parameter at par_start, and then change the parameter by par_inc until the target parameter has reached the target value
  !!  -  'root_finding' -- the same as target, but the increment is changed intelligently using a Newton-like method.
 character :: scan_type
end module parameter_scan
module parameter_scan


   !>Specify the parameter to be varied.  If the parameter pertains to a species, the scan_spec must be specified as well.
 character :: scan_par
end module parameter_scan
module parameter_scan


   !>If the scan is being run in 'target' or 'root_finding' mode, specifies the target parameter. 
  !!  - Possible values are 'hflux_tot', 'momflux_tot', 'phi2_tot'.
 character :: target_par
end module parameter_scan
module parameter_scan


   !>Specifies the starting value for the parameter scan.
 real :: par_start
end module parameter_scan
module parameter_scan


   !>If the scan is being run in 'range' mode, specifies the value of the parameter that will be reached.
 real :: par_end
end module parameter_scan
module parameter_scan


   !>If the parameter scan is being run in 'range' or 'target' modes, specifies the amount by which the parameter is varied at one go.
 real :: par_inc
end module parameter_scan
module parameter_scan


   !>Specifies the condition for incrementing the parameter. Possible values are:
  !!  -  'n_timesteps' -- change the parameter after a given number of time steps
  !!  -  'delta_t' -- change the parameter after an elapsed time
  !!  -  'saturated' -- change the parameter after the simulation has reached a saturated state (determined using the target parameter) at the current value of the parameter
 character :: inc_con
end module parameter_scan
module parameter_scan


   !>When the increment condition is 'n_timesteps' or 'saturated',  the parameter will not be changed until nstep_init have elapsed from the beginning of the simulation. Note that if the simulation is restarted, this parameter will measure from the restart.
 integer :: nstep_init
end module parameter_scan
module parameter_scan


   !>When the increment condition is 'n_timesteps', the parameter will be changed every nstep_inc.
 integer :: nstep_inc
end module parameter_scan
module parameter_scan


   !>When the increment condition is 'delta_t', the parameter will not be changed until delta_t_init time has elapsed from the beginning of the simulation. Note, that if the simulation is restarted, this parameter will measure from beginning of original simulation.
 real :: delta_t_init
end module parameter_scan
module parameter_scan


   !>When the increment condition is 'delta_t', the parameter will be changed every time delta_t time has elapsed.
 real :: delta_t_inc
end module parameter_scan
module parameter_scan


   !>When parameter pertains to a species, specifies the index of the species.
 integer :: scan_spec
end module parameter_scan
module parameter_scan


   !>Must be set to true if the current value of the scan parameter must be read from the restart files.  Otherwise, the scan will start from the beginning.
 logical :: scan_restarted
end module parameter_scan
module parameter_scan


   !>If the scan is being run in 'target' or 'root_finding'  mode, specifies the value to be targeted. The scan will complete when this target value is reached.
 real :: target_val
end module parameter_scan
