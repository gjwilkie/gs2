# This file generates the file gs2_init.f90.
# For more information see the help in gs2_init.f90
# To run:
#    $ ruby gs2_init.rb gs2_init.f90
#
# This is free software released under the MIT licence.
# Written by:
#           Edmund Highcock (edmundhighcock@users.sourceforge.net)

class GenerateInit

  DEPENDENCIES = {'antenna' => ['species'],
                  'theta_grid' => [],
                  'kt_grids' => [],
                  'gs2_layouts' => [],
                  'gs2_save' => [],
                  'run_parameters' => ['kt_grids'],
                  'hyper' => ['kt_grids', 'gs2_layouts'],
                  'init_g' => ['gs2_layouts'],
                  'species' => [],
                  'dist_fn_parameters' => ['gs2_layouts', 'species', 'theta_grid',
                                            'kt_grids', 'le_grids'   ],
                  'dist_fn_arrays' => ['dist_fn_parameters', 'run_parameters',
                                       'nonlinear_terms', 'dist_fn_layouts','nonlinear_terms' ],
                  'le_grids' => ['species', 'kt_grids', 'gs2_layouts', 'theta_grid'],
                  'dist_fn_layouts' => ['species', 'kt_grids', 'gs2_layouts', 'theta_grid'],
                  'nonlinear_terms' => ['species', 'kt_grids', 'gs2_layouts', 'theta_grid', 
                                        'le_grids', 'dist_fn_layouts'],
                  'collisions' => ['species', 'kt_grids', 'gs2_layouts', 'theta_grid', 
                                   'le_grids', 'dist_fn_layouts', 'run_parameters',
                                    'dist_fn_level_2'],
                  'dist_fn_level_1' => ['dist_fn_arrays'], 
                  'dist_fn_level_2' => ['dist_fn_level_1'], 
                  'dist_fn_level_3' => ['dist_fn_level_2', 'hyper'],

                  'fields' => ['collisions', 'antenna', 'dist_fn_level_3']
  }
                  

                  


  # A list of levels in ascending order of dependence, i.e. the leftmost
  # in the array must be initialized first.
  LEVELS = []
            #['theta_grid', 'kt_grids', 'gs2_layouts', 'gs2_save'],
            #['run_parameters', 'init_g', 'species', 'le_grids'],
            #['dist_fn_layouts', 'antenna'],
            #['nonlinear_terms', 'collisions'],
            #['fields'],
           #].flatten
  deps = DEPENDENCIES.dup
  while deps.keys.size > 0
    deps.keys.each do |k|
      if deps[k] - LEVELS == []
        LEVELS.push k
        deps.delete k
      end 
    end
  end 
  
  p LEVELS, 'LEVELS'

  GS2_LEVEL = 1

  @@level_counter = GS2_LEVEL+1
  
  def initialize(level)
    @level_name = level
    @module_name = case level
                   when 'dist_fn_layouts' 
                     'gs2_layouts' 
                   when /^dist_fn_*/
                     'dist_fn'
                   else
                     @level_name
                   end
    @level_number = @@level_counter
    @@level_counter += 1
  end

  def level_declaration
    "integer :: #@level_name = #@level_number"
  end 

  def up
    "if (current%level .lt. init_level_list%#@level_name) call #@level_name"
  end  
  def down
    "if (current%level .le. init_level_list%#@level_name) call #@level_name"
  end  
  def subroutine
    return <<EOF
      subroutine #@level_name
        use unit_tests, only: debug_message
#{
        case @level_name
        when 'dist_fn_layouts'
          str = <<EOF2
        use gs2_layouts, only: init_#@level_name
        use gs2_layouts, only: finish_#@level_name
        use kt_grids, only: naky, ntheta0
        use le_grids, only: nlambda, negrid
        use species, only: nspec
        if (up) call init_#@level_name(naky, ntheta0, nlambda, negrid, nspec) 
        if (down) call finish_#@level_name
EOF2
        when 'le_grids'
          str = <<EOF2
        use #@module_name, only: init_#@level_name
        use #@module_name, only: finish_#@level_name
        logical :: dummy1, dummy2
        if (up) call init_#@level_name(dummy1, dummy2)
        if (down) call finish_#@level_name
EOF2
        else
          str = <<EOF2
        use #@module_name, only: init_#@level_name
        use #@module_name, only: finish_#@level_name
        if (up) call init_#@level_name
        if (down) call finish_#@level_name
EOF2
        end
        str
        
}       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... #@level_name   ')
          current%level = #@level_number
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... #@level_name   ')
          current%level = #@level_number - 1
        end if
      end subroutine #@level_name
EOF
  end



end 

generators = GenerateInit::LEVELS.map{|l| GenerateInit.new(l)}

string = <<EOF
! DO NOT EDIT THIS FILE
! This file is automatically generated by 
! gs2_init.rb


!> This module is analogous to the init() function
!! in Linux-based operating systems: it initialises
!! gs2 to a certain init_level. At a given init level,
!! certain modules are initialised and certain are not.
!!
!! The gs2_init module is used by gs2_main to initialise modules. A typical
!! additional use case for this module is when it is desired
!! to override a given parameter (as in the override_* functions
!! in gs2_main). Gs2 must be taken down to the appropriate 
!! init_level, where all modules which contain any of those
!! parameters are uninitialized. The override is then set
!! and gs2 is brought back up to the highest init_level.
!! 
!! As in Linux, this module cannot be used until a certain
!! basic initialization has happened (think loading the kernel).
!! This basic initialization occurs in gs2_initialize in gs2_main,
!! and set the init_level to gs2_initialized.
!!
!! This is free software released under the MIT licence.
!! Written by:
!!            Edmund Highcock (edmundhighcock@users.sourceforge.net)
module gs2_init
  public :: init_level_type
  public :: init_level_list
  public :: init
  private

  !> A type for labelling the different init
  !! levels available in gs2.
  type init_level_list_type
    !> The init_level reaches gs2
    !! when initialize_gs2 has been called.
    integer :: gs2 = #{GenerateInit::GS2_LEVEL}
    #{generators.map{|g| g.level_declaration}.join("\n    ")}
  end type init_level_list_type

  type(init_level_list_type) :: init_level_list
  
  !> A type for storing the init_level of gs2.
  type init_level_type
    !> The current init level
    integer :: level = 0
    !> Whether or not diagnostics have been initialized
    logical :: diagnostics_initialized = .false.
    !> A list of possible init levels
    !type(init_level_list_type) :: levels
  end type init_level_type
contains
  !> Initialize gs2 to the level of target_level.
  !! The init_level_type current contains info
  !! about the current initialization level. At the end
  !! of the subroutine, current%level is set to target_level
  subroutine init(current, target_level)
    use fields, only: init_fields
    implicit none
    type(init_level_type), intent(inout) :: current
    integer, intent(in) :: target_level
    integer :: i
    logical :: up, down
    down = (target_level<current%level) 
    up = (target_level>current%level) 

    if (current%level .lt. init_level_list%gs2) then
      write (*,*) "gs2_init::init cannot be called before &
       & initialize_gs2 in gs2 main"
      stop 1
    end if 


    if (current%level .eq. target_level) then
      return
    else
      if (up) then 
        #{generators.map{|g| g.up}.join("\n        ")}
      else
        #{generators.reverse.map{|g| g.down}.join("\n        ")}
      end if
    end if
    contains
#{generators.map{|g| g.subroutine}.join("\n")}
  end subroutine init
end module gs2_init

EOF

File.open(ARGV[-1], 'w'){|f| f.puts string}
