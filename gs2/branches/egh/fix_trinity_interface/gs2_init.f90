! DO NOT EDIT THIS FILE
! This file is automatically generated by 
! gs2_init.rb


!> This module is analogous to the init() function
!! in Linux-based operating systems: it initialises
!! gs2 to a certain init_level. At a given init level,
!! certain modules are initialised and certain are not.
!!
!! The gs2_init module is used by gs2_main to initialise modules. A typical
!! additional use case for this module is when it is desired
!! to override a given parameter (as in the override_* functions
!! in gs2_main). Gs2 must be taken down to the appropriate 
!! init_level, where all modules which contain any of those
!! parameters are uninitialized. The override is then set
!! and gs2 is brought back up to the highest init_level.
!! 
!! As in Linux, this module cannot be used until a certain
!! basic initialization has happened (think loading the kernel).
!! This basic initialization occurs in gs2_initialize in gs2_main,
!! and set the init_level to gs2_initialized.
!!
!! This is free software released under the MIT licence.
!! Written by:
!!            Edmund Highcock (edmundhighcock@users.sourceforge.net)
module gs2_init
  public :: init_level_type
  public :: init_level_list
  public :: init
  !> Save the current state of the fields and 
  !! distribution function, either to a file 
  !! or to a temporary array, depending on the
  !! value of in_memory. (NB if there is 
  !! sufficient memory to allocate a temporary
  !! array, in_memory will be overriden to 
  !! false).
  public :: save_fields_and_dist_fn
  public :: load_saved_field_values

  public :: in_memory

  private

  !> A type for labelling the different init
  !! levels available in gs2.
  type init_level_list_type
    !> The init_level reaches gs2
    !! when initialize_gs2 has been called.
    integer :: gs2 = 1
    integer :: gs2_layouts = 2
    integer :: theta_grid = 3
    integer :: kt_grids = 4
    integer :: gs2_save = 5
    integer :: run_parameters = 6
    integer :: hyper = 7
    integer :: init_g = 8
    integer :: species = 9
    integer :: le_grids = 10
    integer :: antenna = 11
    integer :: dist_fn_parameters = 12
    integer :: dist_fn_layouts = 13
    integer :: nonlinear_terms = 14
    integer :: dist_fn_arrays = 15
    integer :: dist_fn_level_1 = 16
    integer :: dist_fn_level_2 = 17
    integer :: override_timestep = 18
    integer :: dist_fn_level_3 = 19
    integer :: collisions = 20
    integer :: fields = 21
  end type init_level_list_type

  type(init_level_list_type) :: init_level_list
  
  !> A type for storing the init_level of gs2.
  type init_level_type
    !> The current init level
    integer :: level = 0
    !> Whether or not diagnostics have been initialized
    logical :: diagnostics_initialized = .false.
    !> A list of possible init levels
    !type(init_level_list_type) :: levels
  end type init_level_type

  complex, dimension(:,:,:), allocatable :: phi_tmp, apar_tmp, bpar_tmp
  logical :: fields_and_dist_fn_saved = .false.
  logical :: in_memory = .false.  
contains
  !> Initialize gs2 to the level of target_level.
  !! The init_level_type current contains info
  !! about the current initialization level. At the end
  !! of the subroutine, current%level is set to target_level
  subroutine init(current, target_level)
    use fields, only: init_fields
    implicit none
    type(init_level_type), intent(inout) :: current
    integer, intent(in) :: target_level
    integer :: i
    logical :: up, down
    down = (target_level<current%level) 
    up = (target_level>current%level) 

    if (current%level .lt. init_level_list%gs2) then
      write (*,*) "gs2_init::init cannot be called before &
       & initialize_gs2 in gs2 main"
      stop 1
    end if 


    if (current%level .eq. target_level) then
      return
    else
      if (up) then 
        if (current%level .lt. init_level_list%gs2_layouts) call gs2_layouts
        if (current%level .lt. init_level_list%theta_grid) call theta_grid
        if (current%level .lt. init_level_list%kt_grids) call kt_grids
        if (current%level .lt. init_level_list%gs2_save) call gs2_save
        if (current%level .lt. init_level_list%run_parameters) call run_parameters
        if (current%level .lt. init_level_list%hyper) call hyper
        if (current%level .lt. init_level_list%init_g) call init_g
        if (current%level .lt. init_level_list%species) call species
        if (current%level .lt. init_level_list%le_grids) call le_grids
        if (current%level .lt. init_level_list%antenna) call antenna
        if (current%level .lt. init_level_list%dist_fn_parameters) call dist_fn_parameters
        if (current%level .lt. init_level_list%dist_fn_layouts) call dist_fn_layouts
        if (current%level .lt. init_level_list%nonlinear_terms) call nonlinear_terms
        if (current%level .lt. init_level_list%dist_fn_arrays) call dist_fn_arrays
        if (current%level .lt. init_level_list%dist_fn_level_1) call dist_fn_level_1
        if (current%level .lt. init_level_list%dist_fn_level_2) call dist_fn_level_2
        if (current%level .lt. init_level_list%override_timestep) call override_timestep
        if (current%level .lt. init_level_list%dist_fn_level_3) call dist_fn_level_3
        if (current%level .lt. init_level_list%collisions) call collisions
        if (current%level .lt. init_level_list%fields) call fields
      else
        if (current%level .le. init_level_list%fields) call fields
        if (current%level .le. init_level_list%collisions) call collisions
        if (current%level .le. init_level_list%dist_fn_level_3) call dist_fn_level_3
        if (current%level .le. init_level_list%override_timestep) call override_timestep
        if (current%level .le. init_level_list%dist_fn_level_2) call dist_fn_level_2
        if (current%level .le. init_level_list%dist_fn_level_1) call dist_fn_level_1
        if (current%level .le. init_level_list%dist_fn_arrays) call dist_fn_arrays
        if (current%level .le. init_level_list%nonlinear_terms) call nonlinear_terms
        if (current%level .le. init_level_list%dist_fn_layouts) call dist_fn_layouts
        if (current%level .le. init_level_list%dist_fn_parameters) call dist_fn_parameters
        if (current%level .le. init_level_list%antenna) call antenna
        if (current%level .le. init_level_list%le_grids) call le_grids
        if (current%level .le. init_level_list%species) call species
        if (current%level .le. init_level_list%init_g) call init_g
        if (current%level .le. init_level_list%hyper) call hyper
        if (current%level .le. init_level_list%run_parameters) call run_parameters
        if (current%level .le. init_level_list%gs2_save) call gs2_save
        if (current%level .le. init_level_list%kt_grids) call kt_grids
        if (current%level .le. init_level_list%theta_grid) call theta_grid
        if (current%level .le. init_level_list%gs2_layouts) call gs2_layouts
      end if
    end if
    contains
      subroutine gs2_layouts
        use unit_tests, only: debug_message
        use gs2_layouts, only: init_gs2_layouts
        use gs2_layouts, only: finish_gs2_layouts
        if (up) call init_gs2_layouts
        if (down) call finish_gs2_layouts
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... gs2_layouts   ')
          current%level = 2
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... gs2_layouts   ')
          current%level = 2 - 1
        end if
      end subroutine gs2_layouts

      subroutine theta_grid
        use unit_tests, only: debug_message
        use theta_grid, only: init_theta_grid
        use theta_grid, only: finish_theta_grid
        if (up) call init_theta_grid
        if (down) call finish_theta_grid
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... theta_grid   ')
          current%level = 3
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... theta_grid   ')
          current%level = 3 - 1
        end if
      end subroutine theta_grid

      subroutine kt_grids
        use unit_tests, only: debug_message
        use kt_grids, only: init_kt_grids
        use kt_grids, only: finish_kt_grids
        if (up) call init_kt_grids
        if (down) call finish_kt_grids
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... kt_grids   ')
          current%level = 4
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... kt_grids   ')
          current%level = 4 - 1
        end if
      end subroutine kt_grids

      subroutine gs2_save
        use unit_tests, only: debug_message
        use gs2_save, only: init_gs2_save
        use gs2_save, only: finish_gs2_save
        if (up) call init_gs2_save
        if (down) call finish_gs2_save
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... gs2_save   ')
          current%level = 5
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... gs2_save   ')
          current%level = 5 - 1
        end if
      end subroutine gs2_save

      subroutine run_parameters
        use unit_tests, only: debug_message
        use run_parameters, only: init_run_parameters
        use run_parameters, only: finish_run_parameters
        if (up) call init_run_parameters
        if (down) call finish_run_parameters
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... run_parameters   ')
          current%level = 6
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... run_parameters   ')
          current%level = 6 - 1
        end if
      end subroutine run_parameters

      subroutine hyper
        use unit_tests, only: debug_message
        use hyper, only: init_hyper
        use hyper, only: finish_hyper
        if (up) call init_hyper
        if (down) call finish_hyper
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... hyper   ')
          current%level = 7
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... hyper   ')
          current%level = 7 - 1
        end if
      end subroutine hyper

      subroutine init_g
        use unit_tests, only: debug_message
        use init_g, only: init_init_g
        use init_g, only: finish_init_g
        if (up) call init_init_g
        if (down) call finish_init_g
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... init_g   ')
          current%level = 8
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... init_g   ')
          current%level = 8 - 1
        end if
      end subroutine init_g

      subroutine species
        use unit_tests, only: debug_message
        use species, only: init_species
        use species, only: finish_species
        if (up) call init_species
        if (down) call finish_species
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... species   ')
          current%level = 9
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... species   ')
          current%level = 9 - 1
        end if
      end subroutine species

      subroutine le_grids
        use unit_tests, only: debug_message
        use le_grids, only: init_le_grids
        use le_grids, only: finish_le_grids
        logical :: dummy1, dummy2
        if (up) call init_le_grids(dummy1, dummy2)
        if (down) call finish_le_grids
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... le_grids   ')
          current%level = 10
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... le_grids   ')
          current%level = 10 - 1
        end if
      end subroutine le_grids

      subroutine antenna
        use unit_tests, only: debug_message
        use antenna, only: init_antenna
        use antenna, only: finish_antenna
        if (up) call init_antenna
        if (down) call finish_antenna
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... antenna   ')
          current%level = 11
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... antenna   ')
          current%level = 11 - 1
        end if
      end subroutine antenna

      subroutine dist_fn_parameters
        use unit_tests, only: debug_message
        use dist_fn, only: init_dist_fn_parameters
        use dist_fn, only: finish_dist_fn_parameters
        if (up) call init_dist_fn_parameters
        if (down) call finish_dist_fn_parameters
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_parameters   ')
          current%level = 12
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_parameters   ')
          current%level = 12 - 1
        end if
      end subroutine dist_fn_parameters

      subroutine dist_fn_layouts
        use unit_tests, only: debug_message
        use gs2_layouts, only: init_dist_fn_layouts
        use gs2_layouts, only: finish_dist_fn_layouts
        use kt_grids, only: naky, ntheta0
        use le_grids, only: nlambda, negrid
        use species, only: nspec
        if (up) call init_dist_fn_layouts(naky, ntheta0, nlambda, negrid, nspec) 
        if (down) call finish_dist_fn_layouts
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_layouts   ')
          current%level = 13
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_layouts   ')
          current%level = 13 - 1
        end if
      end subroutine dist_fn_layouts

      subroutine nonlinear_terms
        use unit_tests, only: debug_message
        use nonlinear_terms, only: init_nonlinear_terms
        use nonlinear_terms, only: finish_nonlinear_terms
        if (up) call init_nonlinear_terms
        if (down) call finish_nonlinear_terms
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... nonlinear_terms   ')
          current%level = 14
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... nonlinear_terms   ')
          current%level = 14 - 1
        end if
      end subroutine nonlinear_terms

      subroutine dist_fn_arrays
        use unit_tests, only: debug_message
        use dist_fn, only: init_dist_fn_arrays
        use dist_fn, only: finish_dist_fn_arrays
        if (up) call init_dist_fn_arrays
        if (down) call finish_dist_fn_arrays
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_arrays   ')
          current%level = 15
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_arrays   ')
          current%level = 15 - 1
        end if
      end subroutine dist_fn_arrays

      subroutine dist_fn_level_1
        use unit_tests, only: debug_message
        use dist_fn, only: init_dist_fn_level_1
        use dist_fn, only: finish_dist_fn_level_1
        if (up) call init_dist_fn_level_1
        if (down) call finish_dist_fn_level_1
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_level_1   ')
          current%level = 16
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_level_1   ')
          current%level = 16 - 1
        end if
      end subroutine dist_fn_level_1

      subroutine dist_fn_level_2
        use unit_tests, only: debug_message
        use dist_fn, only: init_dist_fn_level_2
        use dist_fn, only: finish_dist_fn_level_2
        if (up) call init_dist_fn_level_2
        if (down) call finish_dist_fn_level_2
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_level_2   ')
          current%level = 17
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_level_2   ')
          current%level = 17 - 1
        end if
      end subroutine dist_fn_level_2

      subroutine override_timestep
        use unit_tests, only: debug_message

       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... override_timestep   ')
          current%level = 18
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... override_timestep   ')
          current%level = 18 - 1
        end if
      end subroutine override_timestep

      subroutine dist_fn_level_3
        use unit_tests, only: debug_message
        use dist_fn, only: init_dist_fn_level_3
        use dist_fn, only: finish_dist_fn_level_3
        if (up) call init_dist_fn_level_3
        if (down) call finish_dist_fn_level_3
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... dist_fn_level_3   ')
          current%level = 19
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... dist_fn_level_3   ')
          current%level = 19 - 1
        end if
      end subroutine dist_fn_level_3

      subroutine collisions
        use unit_tests, only: debug_message
        use collisions, only: init_collisions
        use collisions, only: finish_collisions
        if (up) call init_collisions
        if (down) call finish_collisions
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... collisions   ')
          current%level = 20
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... collisions   ')
          current%level = 20 - 1
        end if
      end subroutine collisions

      subroutine fields
        use unit_tests, only: debug_message
        use fields, only: init_fields
        use fields, only: finish_fields
        if (up) call init_fields
        if (down) call finish_fields
       
        if (up) then
          call debug_message(2, 'gs2_init::init reached init level... fields   ')
          current%level = 21
        else  ! (down)
          call debug_message(2, 'gs2_init::init left init level... fields   ')
          current%level = 21 - 1
        end if
      end subroutine fields

  end subroutine init

  subroutine save_fields_and_dist_fn
    use dist_fn_arrays, only: gnew, g_restart_tmp
    use gs2_save, only: gs2_save_for_restart
    use mp, only: proc0, broadcast
    use collisions, only: vnmult
    use gs2_layouts, only: g_lo
    use theta_grid, only: ntgrid
    use file_utils, only: error_unit
    use kt_grids, only: ntheta0, naky
    use run_parameters, only: fphi, fapar, fbpar
    use fields, only:  force_maxwell_reinit
    use fields_arrays, only: phinew, aparnew, bparnew
    use gs2_time, only: user_time, user_dt
    use antenna, only: dump_ant_amp
    use file_utils, only: input_unit, input_unit_exist
    integer :: iostat, istatus
    integer :: in_file
    logical :: exist


    namelist /init_knobs/ in_memory

    if (proc0) then
       in_file = input_unit_exist("init_knobs",exist)
       if(exist) read (unit=in_file, nml=init_knobs)
    endif

    !If we want to do restarts in memory then try to allocate storage
    if(in_memory)then
       !Try to allocate storage to hold g
       allocate(g_restart_tmp(-ntgrid:ntgrid,2,g_lo%llim_proc:g_lo%ulim_alloc),stat=iostat)

       !If allocate failed
       if(iostat.ne.0)then
          !Disable in_memory flag
          in_memory=.false.
          !Print error message
          if (proc0) write(error_unit(), *) "Couldn't allocate temporary storage for g --> Reverting to file based restart"
       else
          !Copy into temporary
          g_restart_tmp=gnew
       endif

       !!!!
       !! NOW WE MAKE COPIES OF THE FIELDS
       !! --> Don't bother if force_maxwell_reinit as we're going to recalculate
       !!!!

       !Try to allocate storage to hold phi
       if(fphi.gt.0.and.(.not.force_maxwell_reinit).and.in_memory)then
          allocate(phi_tmp(-ntgrid:ntgrid,ntheta0,naky),stat=iostat)

          !If allocate failed
          if(iostat.ne.0)then
             !Disable in_memory flag
             in_memory=.false.
             !Print error message
             if (proc0) write(error_unit(), *) "Couldn't allocate temporary storage for phi --> Reverting to file based restart"
          else
             !Copy into temporary
             phi_tmp=phinew
          endif
       endif

       !Try to allocate storage to hold apar
       if(fapar.gt.0.and.(.not.force_maxwell_reinit).and.in_memory)then
          allocate(apar_tmp(-ntgrid:ntgrid,ntheta0,naky),stat=iostat)

          !If allocate failed
          if(iostat.ne.0)then
             !Disable in_memory flag
             in_memory=.false.
             !Print error message
             if (proc0) write(error_unit(), *) "Couldn't allocate temporary storage for apar --> Reverting to file based restart"
          else
             !Copy into temporary
             apar_tmp=aparnew
          endif
       endif

       !Try to allocate storage to hold bpar
       if(fbpar.gt.0.and.(.not.force_maxwell_reinit).and.in_memory)then
          allocate(bpar_tmp(-ntgrid:ntgrid,ntheta0,naky),stat=iostat)

          !If allocate failed
          if(iostat.ne.0)then
             !Disable in_memory flag
             in_memory=.false.
             !Print error message
             if (proc0) write(error_unit(), *) "Couldn't allocate temporary storage for bpar --> Reverting to file based restart"
          else
             !Copy into temporary
             bpar_tmp=bparnew
          endif
       endif

    endif

    if(.not.in_memory)then
       !Should really do this with in_memory=.true. as well but
       !not sure that we really need to as we never read in the dumped data.
       if (proc0) call dump_ant_amp

       call gs2_save_for_restart (gnew, user_time, user_dt, vnmult, istatus, fphi, fapar, fbpar)
    endif
    fields_and_dist_fn_saved = .true.

  end subroutine save_fields_and_dist_fn
  subroutine load_saved_field_values
    use fields_arrays, only: phinew, aparnew, bparnew
    use fields, only: force_maxwell_reinit
    use dist_fn_arrays, only: g_restart_tmp
    use run_parameters, only: fphi, fapar, fbpar
    if(in_memory.and.(.not.force_maxwell_reinit))then
       if(fphi.gt.0) phinew=phi_tmp
       if(fapar.gt.0) aparnew=apar_tmp
       if(fbpar.gt.0) bparnew=bpar_tmp
    endif
    !Deallocate tmp memory
    if(allocated(g_restart_tmp)) deallocate(g_restart_tmp)
    if(allocated(phi_tmp)) deallocate(phi_tmp)
    if(allocated(apar_tmp)) deallocate(apar_tmp)
    if(allocated(bpar_tmp)) deallocate(bpar_tmp)
    fields_and_dist_fn_saved = .false.
  end subroutine load_saved_field_values
end module gs2_init

