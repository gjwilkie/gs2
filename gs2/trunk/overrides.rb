# A file for generating overrides.f90
# To run:
#   ruby overrides.rb overrides.f90
#
# This is free software released under the MIT license
# Written by:
#           Edmund Highcock (edmundhighcock@users.sourceforge.net)
#

class Generator
  def self.generate_type(name, parameter_list)
    return <<EOF
  type #{name}_overrides_type
    !> DO NOT manually set the value of init.
    !! Nasty things may happen.
    logical :: init = .false.
    #{parameter_list.map{|p| p.switch}.join("\n    ")}
    #{parameter_list.map{|p| p.value}.join("\n    ")}
  end type #{name}_overrides_type

EOF
  end
  def self.generate_initialize(name, parameter_list)
    return <<EOF
  #{ 
  if countpar = parameter_list.find{|p| p.count}
   "subroutine init_#{name}_overrides(overrides, #{countpar.count})
    integer, intent(in) :: #{countpar.count}"
  else
   "subroutine init_#{name}_overrides(overrides)"
  end}
    type(#{name}_overrides_type), intent(inout) :: overrides
    if (overrides%init) return 
    overrides%init = .true.
    #{parameter_list.map{|p| p.init}.join("\n    ")}
  end subroutine init_#{name}_overrides

EOF
  end
  def self.generate_finish(name, parameter_list)
    return <<EOF
  subroutine finish_#{name}_overrides(overrides)
    type(#{name}_overrides_type), intent(inout) :: overrides
    if (.not. overrides%init) then
      write (*,*) "ERROR: Called finish_#{name}_overrides on an uninitialized object"
      return
    end if
    overrides%init = .false.
    #{parameter_list.map{|p| p.finish}.join("\n    ")}
  end subroutine finish_#{name}_overrides

EOF
  end

  def switch
    if @count
      "logical, dimension(:), pointer :: override_#@name"
    else
      "logical :: override_#@name"
    end
  end

  def value
    if @count
      "#@type, dimension(:), pointer :: #@name"
    else
      "#@type :: #@name"
    end
  end

  def init
    str = "overrides%override_#@name = .false."
    str = "allocate(overrides%override_#@name(#@count), overrides%#@name(#@count))\n    " + str if @count 
    return str
  end

  def finish
    str = "overrides%override_#@name = .false."
    str = str +  "\n    deallocate(overrides%override_#@name, overrides%#@name)" if @count 
    return str
  end

  attr_reader :count

  def initialize(p)
    @type = p[0]
    @name = p[1]
    @count = p[2]
  end
end 



parameter_list_geo = [
['real', 'rhoc'],
['real', 'qinp'],
['real', 'shat'],
['real', 'rgeo_lcfs'],
['real', 'rgeo_local'],
['real', 'akappa'],
['real', 'akappri'],
['real', 'tri'],
['real', 'tripri'],
['real', 'shift'],
['real', 'betaprim'],
].compact.map{|p| Generator.new(p)}

parameter_list_profs = [
['real', 'dens', 'nspec'],
['real', 'temp', 'nspec'],
['real', 'tprim', 'nspec'],
['real', 'fprim', 'nspec'],
['real', 'vnewk', 'nspec'],
['real', 'g_exb'],
['real', 'mach'],
].compact.map{|p| Generator.new(p)}



string = <<EOF
! DO NOT EDIT THIS FILE
! This file is automatically generated by overrides.rb

module overrides
#{Generator.generate_type('miller_geometry', parameter_list_geo)}
#{Generator.generate_type('profiles', parameter_list_profs)}

!> This one is too complicated to generate 
!! automatically
type initial_values_overrides_type
  logical :: init = .false.
  logical :: in_memory = .true.
  logical :: override = .false.
  !logical :: override_phi = .false.
  !logical :: override_apar = .false.
  !logical :: override_bpar = .false.
  !logical :: override_g = .false.
  logical :: force_maxwell_reinit = .true.
  complex, dimension (:,:,:), pointer :: phi
  complex, dimension (:,:,:), pointer :: apar
  complex, dimension (:,:,:), pointer :: bpar
  complex, dimension (:,:,:), pointer :: g
end type initial_values_overrides_type

contains
#{Generator.generate_initialize('miller_geometry', parameter_list_geo)}
#{Generator.generate_finish('miller_geometry', parameter_list_geo)}
#{Generator.generate_initialize('profiles', parameter_list_profs)}
#{Generator.generate_finish('profiles', parameter_list_profs)}

!> Warning: You can't change the value of overrides%force_maxwell_reinit 
!! or overrides%in_memory after calling this function
subroutine init_initial_values_overrides(overrides, ntgrid, ntheta0, naky, g_llim, g_ulim, force_maxwell_reinit, in_memory)
  use file_utils, only: error_unit
  implicit none
  type(initial_values_overrides_type), intent(inout) :: overrides
  integer, intent(in) :: ntgrid, ntheta0, naky, g_llim, g_ulim
  logical, intent(in) :: force_maxwell_reinit, in_memory
  integer :: iostat
  if (overrides%init) return
  overrides%init = .true.
  overrides%override = .false.
  !overrides%override_phi = .false.
  !overrides%override_apar = .false.
  !overrides%override_bpar = .false.
  !overrides%override_g = .false.
  overrides%force_maxwell_reinit = force_maxwell_reinit
  overrides%in_memory = in_memory

  write (error_unit(), *) "INFO: changing force_maxwell_reinit or in_memory &
    & after calling initial_values_overrides_type will almost certainly cause &
    & segmentation faults."
  if (overrides%in_memory) then 
    allocate(overrides%g(-ntgrid:ntgrid,2,g_llim:g_ulim), stat=iostat)
    if (overrides%force_maxwell_reinit) then 
      if (iostat.eq.0) allocate(overrides%phi(-ntgrid:ntgrid,ntheta0,naky), stat=iostat)
      if (iostat.eq.0) allocate(overrides%apar(-ntgrid:ntgrid,ntheta0,naky), stat=iostat)
      if (iostat.eq.0) allocate(overrides%bpar(-ntgrid:ntgrid,ntheta0,naky), stat=iostat)
    end if
    if (iostat.ne.0) then
      overrides%in_memory = .false.
      write(error_unit(),*) "WARNING: could not allocate memory for initial_values_overrides. Only restart from file possible (manual setting of initial values not possible)"
      if (associated(overrides%g)) deallocate(overrides%g)
      if (associated(overrides%phi)) deallocate(overrides%phi)
      if (associated(overrides%apar)) deallocate(overrides%apar)
      if (associated(overrides%bpar)) deallocate(overrides%bpar)
    end if
  end if
end subroutine init_initial_values_overrides

subroutine finish_initial_values_overrides(overrides)
  implicit none
  type(initial_values_overrides_type), intent(inout) :: overrides
  if (.not. overrides%init) then
    write (*,*) "WARNING: Called finish_initial_values_overrides on an uninitialized object"
    return 
  end if
  overrides%init = .false.
  overrides%override = .false.
  !overrides%override_phi = .false.
  !overrides%override_apar = .false.
  !overrides%override_bpar = .false.
  !overrides%override_g = .false.
  overrides%force_maxwell_reinit = .true.
  if (overrides%in_memory) then 
    deallocate(overrides%phi)
    if (overrides%force_maxwell_reinit) then 
      deallocate(overrides%apar)
      deallocate(overrides%bpar)
      deallocate(overrides%g)
    end if
  end if
end subroutine finish_initial_values_overrides

end module overrides
EOF

File.open(ARGV[-1], 'w'){|f| f.puts string}


